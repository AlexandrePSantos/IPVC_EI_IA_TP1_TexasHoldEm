-------------------action.py:

--> EN <--
Contains an Enum class named TexasAction, which represents the possible actions for Texas Hold'em poker.

FOLD represents the action of folding the hand.
CHECK represents the action of not betting.
CALL represents the action of matching the opponent's bet.
RAISE represents the action of increasing the bet.
----\\----

--> PT <--
Contem uma class Enum TexasAction, que representa as possiveis jogadas para um jogo de Texas Hold'em poker.

FOLD representa a ação de desistir da mão.
CHECK representa a ação de não apostar.
CALL representa a ação de igualar a aposta do adversário.
RAISE representa a ação de aumentar a aposta.
----\\----
----\\----

-------------------card.py:

--> EN <--
Contains an Enum class named TexasCard, which represents a standard deck of cards for Texas Hold'em poker. The class has 52 members,
each representing a unique card in the deck. Each card is identified by a value between 0 and 51, which is stored in the value attribute of each member.

The TexasCard class defines two methods:
->>    __lt__(self, other): This method is used to define the less-than comparison between two TexasCard instances. 
    It compares the value attributes of the two instances to determine which one is less than the other.
->>    __str__(self): This method returns a string representation of the TexasCard instance, which consists of the rank and suit of the card. 
    The rank is determined by the rank_names dictionary, which maps the card's value modulo 13 to a rank name ("2" through "A"). 
    The suit is determined by the suit_names dictionary, which maps the card's value integer divided by 13 to a suit name ("hearts", "diamonds", "clubs", "spades"). 
    The rank and suit are concatenated to form the string representation of the card.
----\\----

--> PT <--
Contem uma classe Enum chamada TexasCard, que representa um baralho padrão de cartas para o jogo de poker Texas Hold'em.
A classe tem 52 elementos, cada um representando uma carta única do baralho. Cada carta é identificada por um valor entre 0 e 51, que é armazenado no atributo de valor de cada elemento.

A classe TexasCard define dois métodos:

->>     __lt__(self, other): Este método é usado para definir a comparação de menor-que entre duas instâncias de TexasCard. 
    Ele compara os atributos de valor das duas instâncias para determinar qual é menor que a outra.
->>     __str__(self): Este método retorna uma representação em string da instância de TexasCard, que consiste no valor e no naipe da carta. 
    O valor é determinado pelo dicionário rank_names, que mapeia o valor da carta módulo 13 para um nome de valor ("2" a "A"). 
    O naipe é determinado pelo dicionário suit_names, que mapeia o valor inteiro da carta dividido por 13 para um nome de naipe ("copas", "ouros", "paus", "espadas"). 
    O valor e o naipe são concatenados para formar a representação em string da carta.
----\\----
----\\----

-------------------player.py:

--> EN <--
Contains a class named TexasPlayer which inherits from the abstract base class Player and from the abstract base class ABC. It also imports the List and TexasCard types from other modules.

The TexasPlayer class has an initializer (__init__ method) that sets the name of the player and initializes the private instance variables __score, __num_games, and __current_hand.
The class has methods for setting and getting the current hand of the player, getting the score of the player, getting the expected value of the player, and printing the statistics of the player.
The event_new_game method increments the number of games for the player when a new game starts, and the event_result method updates the score of the player when a game ends.
Finally, the print_stats method prints the name of the player, the total profit earned or lost by the player, and the profit per game for the player in a formatted string.
----\\----

--> PT <--
Contem uma class chamada TexasPlayer que herda da classe abstrata base Player e da classe abstrata base ABC. Ela também importa os tipos List e TexasCard de outros módulos.

A classe TexasPlayer tem um inicializador (init método) que define o nome do jogador e inicializa as variáveis de instância privadas __score, __num_games e __current_hand.
A classe tem métodos para definir e obter a mão atual do jogador, obter a pontuação do jogador, obter o valor esperado do jogador e imprimir as estatísticas do jogador.
O método event_new_game incrementa o número de jogos para o jogador quando um novo jogo começa, e o método event_result atualiza a pontuação do jogador quando um jogo termina.
Por fim, o método print_stats imprime o nome do jogador, o lucro total obtido ou perdido pelo jogador e o lucro por jogo para o jogador em uma string formatada.
----\\----
----\\----

-------------------simulator.py:

--> EN <--
This code implements the TexasSimulator class, which is a simulator for the Texas Hold'em game with two players.
The class inherits from GameSimulator, an abstract class that defines the basic functionalities of a game simulator.

The class has a constructor that receives two TexasPlayer objects as a parameter and a private variable __deck that contains the deck of cards.
The init_game() method is responsible for initializing the game, shuffling the deck, dealing two cards to each player, and three cards to the table.
    The method returns a TexasState object that represents the current state of the game.

The before_end_game() method is called before the game ends and is responsible for revealing the cards of all players if the game has ended,
    a player has folded, or it is the last betting round.
    The method iterates over all players and calls the draw_card() method of TexasState to reveal their cards.
The end_game() method is called when the game ends and is ignored in this simulator.
----\\----

--> PT <--
Este código implementa a classe TexasSimulator, que é um simulador para o jogo Texas Hold'em com dois jogadores.
A classe herda de GameSimulator, uma classe abstrata que define as funcionalidades básicas de um simulador de jogo.

A classe possui um construtor que recebe dois objetos TexasPlayer como parâmetro e uma variável privada __deck que contém as cartas do baralho.
O método init_game() é responsável por inicializar o jogo, embaralhando o baralho, distribuindo duas cartas para cada jogador e três cartas para a mesa.
    O método retorna um objeto TexasState que representa o estado atual do jogo.

O método before_end_game() é chamado antes do jogo terminar e é responsável por revelar as cartas de todos os jogadores caso o jogo tenha acabado,
    um jogador tenha desistido ou seja a última rodada de apostas.
    O método itera sobre todos os jogadores e chama o método draw_card() de TexasState para revelar suas cartas.
O método end_game() é chamado quando o jogo termina e é ignorado neste simulador.
----\\----
----\\----

-------------------state.py:

--> EN <--

----\\----

--> PT <--

----\\----
----\\----

action.py:

from enum import Enum


class TexasAction(Enum):
    FOLD = 0
    CHECK = 1
    CALL = 2
    RAISE = 3

card.py:

from enum import Enum


class TexasCard(Enum):
    """
    A standard deck of cards for Texas Hold'em poker
    """
    TwoOfHearts = 0
    ThreeOfHearts = 1
    FourOfHearts = 2
    FiveOfHearts = 3
    SixOfHearts = 4
    SevenOfHearts = 5
    EightOfHearts = 6
    NineOfHearts = 7
    TenOfHearts = 8
    JackOfHearts = 9
    QueenOfHearts = 10
    KingOfHearts = 11
    AceOfHearts = 12
    TwoOfDiamonds = 13
    ThreeOfDiamonds = 14
    FourOfDiamonds = 15
    FiveOfDiamonds = 16
    SixOfDiamonds = 17
    SevenOfDiamonds = 18
    EightOfDiamonds = 19
    NineOfDiamonds = 20
    TenOfDiamonds = 21
    JackOfDiamonds = 22
    QueenOfDiamonds = 23
    KingOfDiamonds = 24
    AceOfDiamonds = 25
    TwoOfClubs = 26
    ThreeOfClubs = 27
    FourOfClubs = 28
    FiveOfClubs = 29
    SixOfClubs = 30
    SevenOfClubs = 31
    EightOfClubs = 32
    NineOfClubs = 33
    TenOfClubs = 34
    JackOfClubs = 35
    QueenOfClubs = 36
    KingOfClubs = 37
    AceOfClubs = 38
    TwoOfSpades = 39
    ThreeOfSpades = 40
    FourOfSpades = 41
    FiveOfSpades = 42
    SixOfSpades = 43
    SevenOfSpades = 44
    EightOfSpades = 45
    NineOfSpades = 46
    TenOfSpades = 47
    JackOfSpades = 48
    QueenOfSpades = 49
    KingOfSpades = 50
    AceOfSpades = 51

    def __lt__(self, other):
        if self.__class__ is other.__class__:
            return self.value < other.value

    def __str__(self):
        rank_names = {
            0: "2",
            1: "3",
            2: "4",
            3: "5",
            4: "6",
            5: "7",
            6: "8",
            7: "9",
            8: "10",
            9: "J",
            10: "Q",
            11: "K",
            12: "A"
        }
        suit_names = {
            0: "hearts",
            1: "diamonds",
            2: "clubs",
            3: "spades"
        }
        rank = rank_names[self.value % 13]
        suit = suit_names[self.value // 13]
        return rank + suit


"""
   # kuhn poker is played with 3 cards with no suits

    Jack = 0
    Queen = 1
    King = 2

    def __lt__(self, other):
        if self.__class__ is other.__class__:
            return self.value < other.value

    def __str__(self):
        return {
            0: "J",
            1: "Q",
            2: "K"
        }[self.value]
"""

player.py:

from abc import ABC
from typing import List
from games.player import Player
from games.texasholdem.card import TexasCard


class TexasPlayer(Player, ABC):

    def __init__(self, name):
        super().__init__(name)

        """
        score will store the money earned (or lost)
        """
        self.__score = 0

        """
        here we are storing the number of games
        """
        self.__num_games = 0

        """
        we also need to store the current cards we are holding
        """
        self.__current_hand = []

    """
    assigns a card to the player
    """
    def set_current_hand(self, cards: List[TexasCard]):
        self.__current_hand = cards

    """
    gets the current player's card
    """
    def get_current_hand(self):
        return self.__current_hand

    """
    gets the score
    """
    def get_score(self):
        return self.__score

    """
    gets the score
    """
    def get_expected_value(self):
        return self.__score * 1.0 / self.__num_games

    def event_new_game(self):
        self.__num_games += 1

    def event_result(self, pos: int, result: int):
        if pos == self.get_current_pos():
            self.__score += result

    def print_stats(self):
        print(f"Player {self.get_name()} | Total profit: ${self.__score} "
              f"| Profit per game: ${self.get_expected_value()}")

simulator.py:

from random import shuffle

from games.game_simulator import GameSimulator
from games.texasholdem.card import TexasCard
from games.texasholdem.player import TexasPlayer
from games.texasholdem.state import TexasState


class TexasSimulator(GameSimulator):

    def __init__(self, player1: TexasPlayer, player2: TexasPlayer):
        super().__init__([player1, player2])
        """
        deck of cards
        """
        deck = list(TexasCard)
        self.__deck = deck
        self.state = TexasState()

    def init_game(self):
        # shuffle the deck
        shuffle(self.__deck)

        # assign two cards to each player
        positions = self.get_player_positions()
        for player in positions:
            cards = self.__deck[:2]
            player.set_current_cards(cards)
            self.__deck = self.__deck[2:]

        # assign three community cards
        for i in range(3):
            self.state.add_community_card(self.__deck.pop())

        return self.state

    def before_end_game(self, state: TexasState):
        # reveal all the cards when the game is over, one player folds, or last round of betting
        if state.is_game_over() or state.get_active_players() == 1 or state.get_current_betting_round() == 4:
            for pos in range(self.num_players()):
                state.draw_card(pos, self.__deck[pos])

    def end_game(self, state: TexasState):
        # ignored for this simulator
        pass

state.py:

from games.texasholdem.action import TexasAction
from games.texasholdem.card import TexasCard
from games.state import State


class TexasState(State):

    def __init__(self):
        super().__init__()
        self.__sequence = []
        self.__acting_player = 0
        self.__is_finished = False
        self.__cards = [None, None]
        self.__bets = [0, 0]  # change initial bets to 0
        self.__is_showdown = False
        self.__community_cards = []

    def get_num_players(self):
        return 2

    def get_valid_actions(self):
        if self.__is_finished:
            return []

        if len(self.__sequence) == 0:
            return [TexasAction.BET]

        last_action = self.__sequence[-1]

        if last_action == TexasAction.BET:
            return [TexasAction.BET, TexasAction.PASS]
        else:
            return [TexasAction.BET]

    def validate_action(self, action) -> bool:
        if self.__is_finished:
            return False
        if action == TexasAction.BET:
            # check if the current player has enough chips to bet
            current_player_chips = self.get_chips(self.__acting_player)
            return self.__bets[self.__acting_player] < current_player_chips
        return True

    def update(self, action):
        if len(self.__sequence) > 0:
            last_action = self.__sequence[-1]

            if last_action == TexasAction.BET:
                self.__is_finished = True
                if action == TexasAction.BET:
                    self.__is_showdown = True
            else:
                if action == TexasAction.PASS:
                    self.__is_finished = True
                    self.__is_showdown = True

        self.__sequence.append(action)

        if action == TexasAction.BET:
            current_bet = self.__bets[self.__acting_player]
            current_player_chips = self.get_chips(self.__acting_player)
            # increase bet by minimum of 1 and remaining chips
            self.__bets[self.__acting_player] += min(current_player_chips - current_bet, 1)

        self.__acting_player = 1 if self.__acting_player == 0 else 0

    def display(self):
        for action in self.__sequence:
            print('b' if action == TexasAction.BET else 'p', end="")
        print(f": pot = {self.get_pot()}")

    def add_community_card(self, card: TexasCard):
        self.__community_cards.append(card)

    def get_pot(self):
        return sum(self.__bets)

    def is_finished(self) -> bool:
        return self.__is_finished

    def get_acting_player(self) -> int:
        return self.__acting_player

    def clone(self):
        cloned = TexasState()
        cloned.__bets = self.__bets.copy()
        cloned.__sequence = self.__sequence.copy()
        cloned.__is_finished = self.__is_finished
        cloned.__acting_player = self.__acting_player
        cloned.__cards = [card.clone() if card is not None else None for card in self.__cards]
        cloned.__is_showdown = self.__is_showdown
        return cloned

    def get_result(self, pos):
        if not self.__is_finished:
            return None

        if self.__is_showdown:
            for card in self.__cards:
                if card is None:
                    return None

            opp_pos = 1 if pos == 0 else 0
            player_cards = [self.__cards[pos], self.__cards[2+pos]]
            opp_cards = [self.__cards[opp_pos], self.__cards[2+opp_pos]]

            player_hand_strength = self.get_hand_strength(player_cards)
            opp_hand_strength = self.get_hand_strength(opp_cards)

            if player_hand_strength > opp_hand_strength:
                return self.get_pot()
            elif player_hand_strength < opp_hand_strength:
                return -self.get_pot()
            else:
                return

    def before_results(self):
        pass

human.py:

from games.texasholdem.action import TexasAction
from games.texasholdem.player import TexasPlayer
from games.texasholdem.state import TexasState
from games.state import State


class HumanTexasPlayer(TexasPlayer):

    def __init__(self, name):
        super().__init__(name)
        self.current_card = None

    def set_current_card(self, card):
        self.current_card = card

    def get_current_card(self):
        return self.current_card

    def set_current_cards(self, cards):
        self.current_cards = cards

    def get_action(self, state: TexasState):
        state.display()
        valid_actions = state.get_valid_actions()
        while True:
            action_str = input("Choose an action (fold/f, check/c, call, raise/r): ")
            if action_str in ["fold", "f"]:
                return TexasAction.FOLD
            elif action_str in ["check", "c"]:
                return TexasAction.CHECK
            elif action_str == "call":
                return TexasAction.CALL
            elif action_str in ["raise", "r"]:
                bet = input("Enter the amount you want to raise: ")
                try:
                    bet = int(bet)
                    if bet < state.current_bet:
                        print(f"The bet must be at least {state.current_bet}")
                    elif bet > self.chips:
                        print("You don't have enough chips to make that bet")
                    else:
                        return TexasAction.BET, bet
                except ValueError:
                    print("Invalid bet amount. Please enter a number.")
            else:
                print("Invalid action. Please choose one of the valid actions:")
                print([action.value for action in valid_actions])

    def event_action(self, pos: int, action, new_state: State):
        print(f"> player {pos} {action}")

    def event_end_game(self, final_state: State):
        pass

    def event_result(self, pos: int, result: int):
        print(f"> player {pos} got ${result}")

    def event_new_game(self):
        print("--- New game ---")
        print(f"> You are player {self.get_current_pos()} with card {self.get_current_card()}")

